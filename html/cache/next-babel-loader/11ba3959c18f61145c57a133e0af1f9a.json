{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nvar __jsx = React.createElement;\nimport React, { useEffect, useRef, useState } from 'react';\nimport * as S from './styled-elements';\nimport Link from 'next/link';\nimport useSWR from 'swr';\nimport { THEME } from '../../styles/theme';\nimport { Close } from '../icons';\nimport { useScrollContext } from '../scrollContext';\nvar colors = THEME.colors;\n\nvar fetcher = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url) {\n    var res, data;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(url);\n\n          case 2:\n            res = _context.sent;\n            _context.next = 5;\n            return res.json();\n\n          case 5:\n            data = _context.sent;\n\n            if (!(res.status !== 200)) {\n              _context.next = 8;\n              break;\n            }\n\n            throw new Error(data.message);\n\n          case 8:\n            return _context.abrupt(\"return\", data);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetcher(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar PlaylistDetails = function PlaylistDetails(_ref2) {\n  var pid = _ref2.pid,\n      playlist = _ref2.playlist,\n      close = _ref2.close;\n  var scroll = useScrollContext();\n  var scrollRef = useRef(null);\n\n  var _useSWR = useSWR(!pid ? null : function () {\n    return \"/api/spotify/\".concat(pid);\n  }, fetcher),\n      data = _useSWR.data,\n      error = _useSWR.error;\n\n  var _useState = useState(false),\n      hoverClose = _useState[0],\n      setHoverClose = _useState[1];\n\n  useEffect(function () {\n    if (scrollRef && scrollRef.current) {\n      scrollRef.current.scrollTop = 0;\n    }\n  }, [pid]);\n\n  var _ref3 = data || {},\n      images = _ref3.images,\n      name = _ref3.name,\n      tracks = _ref3.tracks,\n      external_urls = _ref3.external_urls;\n\n  return __jsx(S.Drawer, {\n    $scrolled: scroll.isScrolled,\n    $scrolling: scroll.scrolling,\n    $active: pid\n  }, __jsx(S.Section, {\n    id: \"playlist-details\",\n    $scrolled: scroll.isScrolled,\n    $active: pid\n  }, error || !data ? null : __jsx(S.ScrollContainer, {\n    ref: scrollRef\n  }, __jsx(S.Meta, null, __jsx(\"a\", {\n    href: external_urls.spotify,\n    target: \"spotify\"\n  }, __jsx(S.PlistName, null, name))), __jsx(S.Cover, null, __jsx(\"a\", {\n    href: external_urls.spotify,\n    target: \"spotify\"\n  }, __jsx(S.CoverImg, {\n    src: images[0].url\n  }))), __jsx(S.Songs, null, __jsx(S.TrackList, null, tracks.items.map(function (t) {\n    return __jsx(S.Track, {\n      key: t.sharing_info.share_id\n    }, __jsx(S.TrackLink, {\n      href: t.track.external_urls.api,\n      target: \"spotify\"\n    }, __jsx(\"strong\", null, t.track.name), __jsx(\"br\", null), t.track.artists.map(function (a) {\n      return __jsx(S.Artist, {\n        key: \"\".concat(pid, \"_\").concat(a.id)\n      }, a.name);\n    })));\n  }))), __jsx(S.Action, null, __jsx(S.Go, {\n    href: external_urls.spotify,\n    target: \"spotify\"\n  }, 'Listen on Spotify')))), __jsx(S.Close, {\n    $active: pid,\n    onClick: close,\n    onMouseEnter: function onMouseEnter() {\n      return setHoverClose(true);\n    },\n    onMouseLeave: function onMouseLeave() {\n      return setHoverClose(false);\n    }\n  }, __jsx(S.Icon, null, __jsx(Close, {\n    alt: \"Close\",\n    width: \"50%\",\n    height: \"auto\",\n    fill: hoverClose && colors.heliotrope\n  }))));\n};\n\nexport default PlaylistDetails;","map":null,"metadata":{},"sourceType":"module"}